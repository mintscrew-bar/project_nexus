generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// User & Authentication
// ============================================

model User {
  id            String        @id @default(cuid())
  email         String?       @unique
  emailVerified Boolean       @default(false)
  password      String?       // bcrypt hash for email auth
  username      String
  avatar        String?
  role          UserRole      @default(USER)
  reputation    Int           @default(100)
  isRestricted  Boolean       @default(false)
  restrictedUntil DateTime?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  // Online status
  status        UserStatus    @default(OFFLINE)
  lastSeenAt    DateTime?

  reputationScore Float?          // 평판 점수 (1-5)
  isBanned        Boolean         @default(false)
  banReason       String?
  bannedAt        DateTime?
  banUntil        DateTime?       // 임시 밴 만료 시간

  // Relations
  authProviders      AuthProvider[]
  termsAgreements    TermsAgreement[]
  settings           UserSettings?
  riotAccounts       RiotAccount[]
  hostedRooms        Room[]                 @relation("RoomHost")
  roomParticipations RoomParticipant[]
  captainedTeams     Team[]                 @relation("TeamCaptain")
  teamMembers        TeamMember[]
  sessions           Session[]
  clanMemberships    ClanMember[]
  ownedClans         Clan[]                 @relation("ClanOwner")
  posts              Post[]
  comments           Comment[]
  postLikes          PostLike[]
  ratingsGiven       UserRating[]           @relation("RaterUser")
  ratingsReceived    UserRating[]           @relation("RatedUser")
  reportsSubmitted   UserReport[]           @relation("ReporterUser")
  reportsReceived    UserReport[]           @relation("ReportedUser")
  friendships        Friendship[]           @relation("UserFriendships")
  friendOf           Friendship[]           @relation("FriendOfUser")
  chatMessages       ChatMessage[]
  clanChatMessages   ClanChatMessage[]
  snakeDraftPicks    SnakeDraftPick[]
  matchParticipations MatchParticipant[]
  notifications       Notification[]

  @@index([email])
  @@index([reputation])
  @@map("users")
}

enum UserRole {
  USER
  MODERATOR
  ADMIN
}

enum UserStatus {
  ONLINE
  OFFLINE
  AWAY
}

model AuthProvider {
  id         String       @id @default(cuid())
  userId     String
  provider   AuthProviderType
  providerId String       // Discord ID, Google ID, etc.
  metadata   Json?        // Store additional provider-specific data
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerId])
  @@index([userId])
  @@map("auth_providers")
}

enum AuthProviderType {
  EMAIL
  GOOGLE
  DISCORD
}

model TermsAgreement {
  id                String   @id @default(cuid())
  userId            String
  termsOfService    Boolean  @default(false)
  privacyPolicy     Boolean  @default(false)
  ageVerification   Boolean  @default(false)
  marketingConsent  Boolean  @default(false)
  agreedAt          DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("terms_agreements")
}

model Session {
  id           String   @id @default(cuid())
  userId       String
  refreshToken String   @unique
  userAgent    String?
  ipAddress    String?
  expiresAt    DateTime
  createdAt    DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("sessions")
}

model UserSettings {
  id     String @id @default(cuid())
  userId String @unique

  // Notification settings
  notifyFriendRequest Boolean @default(true)
  notifyFriendAccepted Boolean @default(true)
  notifyMatchStart   Boolean @default(true)
  notifyMatchResult  Boolean @default(true)
  notifyTeamInvite   Boolean @default(true)
  notifyMention      Boolean @default(true)
  notifyComment      Boolean @default(true)
  notifyClanActivity Boolean @default(true)
  notifySystem       Boolean @default(true)

  // Privacy settings
  showOnlineStatus   Boolean @default(true)
  showMatchHistory   Boolean @default(true)
  allowFriendRequests Boolean @default(true)

  // Appearance settings
  theme     String @default("dark") // "dark", "light", "system"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_settings")
}

// ============================================
// Riot Account & Champion Preferences
// ============================================

model RiotAccount {
  id            String    @id @default(cuid())
  userId        String
  puuid         String    @unique
  summonerId    String?   // Optional - PUUID is used for all API calls
  gameName      String
  tagLine       String

  // Current rank
  tier          String    @default("UNRANKED")
  rank          String    @default("")
  lp            Int       @default(0)

  // User reported peak tier
  peakTier      String?
  peakRank      String?

  // Roles
  mainRole      Role?
  subRole       Role?

  isPrimary     Boolean   @default(false)
  verifiedAt    DateTime?
  lastSyncedAt  DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  championPreferences ChampionPreference[]

  @@unique([gameName, tagLine])
  @@index([userId])
  @@index([puuid])
  @@map("riot_accounts")
}

enum Role {
  TOP
  JUNGLE
  MID
  ADC
  SUPPORT
}

model ChampionPreference {
  id             String   @id @default(cuid())
  riotAccountId  String
  role           Role
  championId     String   // Champion key from Data Dragon
  order          Int      // Display order (1, 2, 3, ...)
  createdAt      DateTime @default(now())

  riotAccount RiotAccount @relation(fields: [riotAccountId], references: [id], onDelete: Cascade)

  @@unique([riotAccountId, role, championId])
  @@index([riotAccountId, role])
  @@map("champion_preferences")
}

// ============================================
// Room System
// ============================================

model Room {
  id              String       @id @default(cuid())
  name            String
  hostId          String
  password        String?      // bcrypt hash for private rooms
  maxParticipants Int          @default(10) // 10, 15, 20
  isPrivate       Boolean      @default(false)
  status          RoomStatus   @default(WAITING)

  // Settings
  teamMode        TeamMode     @default(SNAKE_DRAFT)
  allowSpectators Boolean      @default(true)

  // Auction Settings
  startingPoints  Int?
  minBidIncrement Int?
  bidTimeLimit    Int?         @default(30) // seconds

  // Snake Draft Settings
  pickTimeLimit     Int?                    @default(60) // seconds
  captainSelection  TeamCaptainSelection?   @default(RANDOM)

  // Discord integration
  discordGuildId     String?
  discordCategoryId  String?

  startedAt       DateTime?
  completedAt     DateTime?
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  host              User                @relation("RoomHost", fields: [hostId], references: [id])
  participants      RoomParticipant[]
  teams             Team[]
  matches           Match[]
  chatMessages      ChatMessage[]
  discordChannels   RoomDiscordChannel[]
  snakeDraftPicks   SnakeDraftPick[]

  @@index([hostId])
  @@index([status])
  @@index([isPrivate])
  @@map("rooms")
}

enum RoomStatus {
  WAITING
  TEAM_SELECTION
  DRAFT
  DRAFT_COMPLETED
  ROLE_SELECTION
  IN_PROGRESS
  COMPLETED
}

enum TeamMode {
  SNAKE_DRAFT
  AUCTION
}

enum TeamCaptainSelection {
    RANDOM
    TIER
}


model RoomParticipant {
  id              String                @id @default(cuid())
  roomId          String
  userId          String
  role            RoomParticipantRole   @default(PLAYER)
  isReady         Boolean               @default(false)
  isCaptain       Boolean               @default(false)
  teamId          String?
  joinedAt        DateTime              @default(now())

  room  Room  @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  team  Team? @relation(fields: [teamId], references: [id])

  @@unique([roomId, userId])
  @@index([roomId])
  @@index([userId])
  @@index([teamId])
  @@map("room_participants")
}

enum RoomParticipantRole {
  PLAYER
  SPECTATOR
}

model ChatMessage {
  id        String   @id @default(cuid())
  roomId    String
  userId    String
  content   String
  createdAt DateTime @default(now())

  room Room @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([roomId, createdAt])
  @@index([userId])
  @@map("chat_messages")
}

model RoomDiscordChannel {
  id        String   @id @default(cuid())
  roomId    String
  channelId String   @unique
  channelType DiscordChannelType
  teamName  String?  // For team-specific voice channels
  createdAt DateTime @default(now())

  room Room @relation(fields: [roomId], references: [id], onDelete: Cascade)

  @@index([roomId])
  @@map("room_discord_channels")
}

enum DiscordChannelType {
  VOICE
  TEXT
}

// ============================================
// Team System (Snake Draft & Auction)
// ============================================

model Team {
  id          String   @id @default(cuid())
  roomId      String
  name        String
  captainId   String
  color       String?  // Hex color for UI

  // Auction specific
  initialBudget Int      @default(0)
  remainingBudget Int    @default(0)
  hasReceivedBonus Boolean @default(false)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  room            Room              @relation(fields: [roomId], references: [id], onDelete: Cascade)
  captain         User              @relation("TeamCaptain", fields: [captainId], references: [id])
  members         TeamMember[]
  snakeDraftPicks SnakeDraftPick[]
  auctionBids     AuctionBid[]
  matchesAsTeamA  Match[]           @relation("TeamA")
  matchesAsTeamB  Match[]           @relation("TeamB")
  wonMatches      Match[]           @relation("MatchWinner")
  roomParticipants RoomParticipant[]
  matchParticipants MatchParticipant[]
  matchTeamStats    MatchTeamStats[]

  @@index([roomId])
  @@index([captainId])
  @@map("teams")
}

model TeamMember {
  id         String    @id @default(cuid())
  teamId     String
  userId     String
  assignedRole Role?
  soldPrice  Int?      // For auction mode
  pickOrder  Int?      // For snake draft mode
  joinedAt   DateTime  @default(now())

  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
  @@index([teamId])
  @@index([userId])
  @@map("team_members")
}

// ============================================
// Snake Draft
// ============================================

model SnakeDraftPick {
  id         String   @id @default(cuid())
  roomId     String
  teamId     String
  userId     String
  pickNumber Int
  createdAt  DateTime @default(now())

  room Room @relation(fields: [roomId], references: [id], onDelete: Cascade)
  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([roomId])
  @@index([teamId])
  @@map("snake_draft_picks")
}

// ============================================
// Auction System
// ============================================

model AuctionBid {
  id           String   @id @default(cuid())
  roomId       String
  teamId       String
  targetUserId String   // Player being bid on
  amount       Int
  isYuchal     Boolean  @default(false) // 유찰 (no sale)
  createdAt    DateTime @default(now())

  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@index([roomId, createdAt])
  @@index([teamId])
  @@index([targetUserId])
  @@map("auction_bids")
}

// ============================================
// Match System
// ============================================

model Match {
  id              String       @id @default(cuid())
  roomId          String
  teamAId         String
  teamBId         String
  winnerId        String?
  status          MatchStatus  @default(PENDING)
  matchNumber     Int?         // For tournaments (1, 2, 3...)
  bracketRound    String?      // "quarter", "semi", "final"
  round           Int?
  bracketType     BracketType?

  // Riot integration
  tournamentCode  String?
  riotMatchId     String?

  scheduledAt     DateTime?
  startedAt       DateTime?
  completedAt     DateTime?
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  room   Room  @relation(fields: [roomId], references: [id], onDelete: Cascade)
  teamA  Team  @relation("TeamA", fields: [teamAId], references: [id])
  teamB  Team  @relation("TeamB", fields: [teamBId], references: [id])
  winner Team? @relation("MatchWinner", fields: [winnerId], references: [id])

  ratings       UserRating[]
  reports       UserReport[]
  participants  MatchParticipant[]
  teamStats     MatchTeamStats[]

  @@index([roomId])
  @@index([teamAId])
  @@index([teamBId])
  @@index([status])
  @@map("matches")
}

enum BracketType {
  SINGLE
  ROUND_ROBIN
  SINGLE_ELIMINATION
}

enum MatchStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
}

// ============================================
// Match Details (Riot API Data)
// ============================================

model MatchParticipant {
  id              String   @id @default(cuid())
  matchId         String
  userId          String
  teamId          String

  // Champion & Position
  championId      Int
  championName    String
  position        String   // TOP, JUNGLE, MID, ADC, SUPPORT

  // Summoner Spells
  summoner1Id     Int
  summoner2Id     Int

  // KDA
  kills           Int
  deaths          Int
  assists         Int

  // Farm & Gold
  totalMinionsKilled      Int
  neutralMinionsKilled    Int
  goldEarned              Int
  goldSpent               Int

  // Damage & Combat
  totalDamageDealt            Int
  totalDamageDealtToChampions Int
  totalDamageTaken            Int
  totalHeal                   Int
  damageSelfMitigated         Int

  // Vision
  visionScore             Int
  wardsPlaced             Int
  wardsKilled             Int
  detectorWardsPlaced     Int

  // Items (final build)
  item0       Int
  item1       Int
  item2       Int
  item3       Int
  item4       Int
  item5       Int
  item6       Int  // Trinket

  // Perks (Runes) - stored as JSON
  perks       Json

  // Stats
  champLevel              Int
  largestKillingSpree     Int
  largestMultiKill        Int
  longestTimeSpentLiving  Int
  totalTimeSpentDead      Int

  // Objectives
  turretKills             Int
  inhibitorKills          Int
  dragonKills             Int
  baronKills              Int

  // Performance
  doubleKills             Int
  tripleKills             Int
  quadraKills             Int
  pentaKills              Int
  firstBloodKill          Boolean
  firstTowerKill          Boolean

  // Result
  win                     Boolean

  createdAt   DateTime @default(now())

  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  team  Team  @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@index([matchId])
  @@index([userId])
  @@index([teamId])
  @@index([championId])
  @@map("match_participants")
}

model MatchTeamStats {
  id              String   @id @default(cuid())
  matchId         String
  teamId          String
  win             Boolean

  // Objectives
  towerKills      Int
  inhibitorKills  Int
  baronKills      Int
  dragonKills     Int
  riftHeraldKills Int

  // Bans
  bans            Json     // Array of champion IDs

  createdAt       DateTime @default(now())

  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  team  Team  @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([matchId, teamId])
  @@index([matchId])
  @@index([teamId])
  @@map("match_team_stats")
}

// ============================================
// Clan System
// ============================================

model Clan {
  id          String     @id @default(cuid())
  name        String     @unique
  tag         String     @unique // [TAG] format
  description String?
  logo        String?
  ownerId     String
  isRecruiting Boolean   @default(true)
  maxMembers  Int        @default(50)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  minTier   String?    // 최소 티어 요구사항
  discord   String?    // 디스코드 링크

  owner   User         @relation("ClanOwner", fields: [ownerId], references: [id])
  members ClanMember[]
  chatMessages ClanChatMessage[]

  @@index([ownerId])
  @@index([isRecruiting])
  @@map("clans")
}

model ClanMember {
  id        String         @id @default(cuid())
  clanId    String
  userId    String
  role      ClanRole @default(MEMBER)
  joinedAt  DateTime       @default(now())

  clan Clan @relation(fields: [clanId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([clanId, userId])
  @@index([clanId])
  @@index([userId])
  @@map("clan_members")
}

enum ClanRole {
  OWNER
  OFFICER
  MEMBER
}

model ClanChatMessage {
  id        String   @id @default(cuid())
  clanId    String
  userId    String
  content   String
  createdAt DateTime @default(now())

  clan Clan @relation(fields: [clanId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([clanId, createdAt])
  @@map("clan_chat_messages")
}

// ============================================
// Community / Forum
// ============================================

model Post {
  id        String       @id @default(cuid())
  title     String
  content   String
  category  PostCategory
  authorId  String
  views     Int          @default(0)
  isPinned  Boolean      @default(false)
  isEdited  Boolean      @default(false)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  author   User       @relation(fields: [authorId], references: [id], onDelete: Cascade)
  comments Comment[]
  likes    PostLike[]

  @@index([category, isPinned, createdAt])
  @@index([authorId])
  @@map("posts")
}

enum PostCategory {
  NOTICE
  FREE
  TIP
  QNA
}

model Comment {
  id        String    @id @default(cuid())
  postId    String
  authorId  String
  content   String
  parentId  String?   // 대댓글 지원
  isEdited  Boolean   @default(false)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  post    Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  author  User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parent  Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies Comment[] @relation("CommentReplies")

  @@index([postId, createdAt])
  @@index([parentId])
  @@map("comments")
}

model PostLike {
  id        String   @id @default(cuid())
  postId    String
  userId    String
  createdAt DateTime @default(now())

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@index([postId])
  @@map("post_likes")
}

// ============================================
// Reputation System
// ============================================

model UserRating {
  id                   String   @id @default(cuid())
  reporterId           String
  targetUserId         String
  matchId              String
  skillRating          Int      // 1-5
  attitudeRating       Int      // 1-5
  communicationRating  Int      // 1-5
  comment              String?
  createdAt            DateTime @default(now())

  reporter User  @relation("RaterUser", fields: [reporterId], references: [id], onDelete: Cascade)
  target   User  @relation("RatedUser", fields: [targetUserId], references: [id], onDelete: Cascade)
  match    Match @relation(fields: [matchId], references: [id], onDelete: Cascade)

  @@unique([reporterId, targetUserId, matchId])
  @@index([targetUserId])
  @@map("user_ratings")
}

model UserReport {
  id           String       @id @default(cuid())
  reporterId   String
  targetUserId String
  matchId      String?
  reason       ReportReason
  description  String
  status       ReportStatus @default(PENDING)
  reviewerNote String?
  reviewedAt   DateTime?
  createdAt    DateTime     @default(now())

  reporter User   @relation("ReporterUser", fields: [reporterId], references: [id], onDelete: Cascade)
  target   User   @relation("ReportedUser", fields: [targetUserId], references: [id], onDelete: Cascade)
  match    Match? @relation(fields: [matchId], references: [id], onDelete: SetNull)

  @@index([targetUserId, status, createdAt])
  @@index([status])
  @@map("user_reports")
}

enum ReportReason {
  TOXICITY
  AFK
  GRIEFING
  CHEATING
  OTHER
}

enum ReportStatus {
  PENDING
  APPROVED
  REJECTED
}

// ============================================
// Friend System
// ============================================

model Friendship {
  id        String           @id @default(cuid())
  userId    String
  friendId  String
  status    FriendshipStatus @default(PENDING)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  user   User @relation("UserFriendships", fields: [userId], references: [id], onDelete: Cascade)
  friend User @relation("FriendOfUser", fields: [friendId], references: [id], onDelete: Cascade)

  @@unique([userId, friendId])
  @@index([userId, status])
  @@index([friendId, status])
  @@map("friendships")
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

// ============================================
// Notification System
// ============================================

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  link      String?
  isRead    Boolean          @default(false)
  data      Json?            // Additional data (JSON)
  createdAt DateTime         @default(now())
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead, createdAt])
  @@index([userId, createdAt])
  @@map("notifications")
}

// Riot Match-V5 데이터 영구 캐시
// - matchId를 PK로 한 번 가져온 매치는 DB에 저장
// - 재방문 시 Riot API 호출 없이 DB에서 즉시 조회
// - 챔피언 통계 등 시즌 전체 집계에 활용
model RiotMatchCache {
  matchId   String   @id
  data      Json     // Full MatchDto JSON
  queueId   Int      // match.info.queueId (빠른 필터링용)
  gameEnd   DateTime // match.info.gameEndTimestamp
  createdAt DateTime @default(now())

  @@index([queueId])
  @@index([gameEnd])
  @@map("riot_match_cache")
}

enum NotificationType {
  FRIEND_REQUEST
  FRIEND_ACCEPTED
  MATCH_STARTING
  MATCH_RESULT
  TEAM_INVITE
  MENTION
  COMMENT
  SYSTEM
}
